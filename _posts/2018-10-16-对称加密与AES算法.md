---
title: 对称加密与AES算法
date: 2018-10-16 18:41:50
tags: 算法
categories: [算法, 密码学]
---

### 对称加密
加密和解密使用同一个密钥的方式成为共享密钥加密（Common key crypto system），也被成为对称密钥加密。
以共享的方式加密时必须将密钥也发送给对方。

<!-- more -->

### AES算法
高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。
对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：
![](/images/aes1.png)

* 明文P：没有经过加密的数据。
* 密钥K：用来加密明文的密码，在对称加密算法中，加密与解密的密钥是相同的。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取机密数据。
* AES加密函数：设AES加密函数为E，则 C = E(K, P),其中P为明文，K为密钥，C为密文。也就是说，把明文P和密钥K作为加密函数的参数输入，则加密函数E会输出密文C。
* 密文C：经加密函数处理后的数据。
* AES解密函数：设AES解密函数为D，则 P = D(K, C),其中C为密文，K为密钥，P为明文。也就是说，把密文C和密钥K作为解密函数的参数输入，则解密函数会输出明文P。

AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特。

### Java实现

首先生成一个秘钥：
```java
/**
 * AES密钥生成器,生成16进制格式的密钥
 * 密钥长度可以是128，192或256比特,这里生成的是128bit的16进制字符串,长度为32 (4*32=128)
 */
public static String generateAESKey() {
    try {
        KeyGenerator generator = KeyGenerator.getInstance("AES");
        generator.init(128); //128bit
        SecretKey secretKey = generator.generateKey();
        return DatatypeConverter.printHexBinary(secretKey.getEncoded());//16进制编码后返回
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    }
}
```
AES属于对称加密，内容传输之前，前端使用密钥将内容加密，后端拿到后，使用相同的密钥将内容解密。


```java
/**
 * AES加密
 * @param hexStringKey 16进制密钥
 * @param initVector 初始向量 iv
 * @param value 待加密内容
 * @return Base64编码的加密内容
 */
public static String encryptIVHexKey(String hexStringKey, String initVector, String value) {
    try {
        IvParameterSpec iv = new IvParameterSpec(initVector.getBytes("UTF-8"));
        byte[] decodedKey = DatatypeConverter.parseHexBinary(hexStringKey);
        SecretKey secretKey = new SecretKeySpec(decodedKey, 0, decodedKey.length, "AES");
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);

        byte[] encrypted = cipher.doFinal(value.getBytes());
        return Base64.encodeBase64String(encrypted);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
    return null;
}

/**
 * AES解密
 * @param hexStringKey 16进制密钥
 * @param initVector 初始向量 iv
 * @param encrypted 待解密内容,Base64编码
 * @return 解密后的内容
 */
public static String decryptIVHexKey(String hexStringKey, String initVector, String encrypted) {
    try {
        IvParameterSpec iv = new IvParameterSpec(initVector.getBytes("UTF-8"));
        byte[] decodedKey = DatatypeConverter.parseHexBinary(hexStringKey);
        SecretKey secretKey = new SecretKeySpec(decodedKey, 0, decodedKey.length, "AES");
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
        cipher.init(Cipher.DECRYPT_MODE, secretKey, iv);
        byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));
        return new String(original);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
    return null;
}


public static void main(String[] args) throws Exception {
    String key = "30023E85AE254CF431FAAB0E3325B3D6"; // 128 bit key
    String initVector = "1234567890123456"; // 16 bytes IV
    System.out.println(decryptIVHexKey(key, initVector,
            encryptIVHexKey(key, initVector, "123abc")));

}
```
注意，iv需要是16bit。前后端一致。

### 2.js
```html
<!DOCTYPE html>
<html>
<head>
    <title>aes demo</title>
    <meta charset="utf-8"/>
    <style>
        *{margin:0;padding:0}
        .demo-wrap{width: 400px;height: 50px;margin: 50px auto auto auto}
    </style>
    <script src="./rollups/aes.js"></script>
</head>
<body>
<div class="demo-wrap">
    <input type="text" id="data-ipt"/>
    <button onclick="getAES();">AES加密</button>
    <button onclick="getDAes();">AES解密</button>
    <br/>
    加密后的数据:
    <p id = "encrypted"></p>
    解密后的数据:
    <p id="decrypted"></p>
</div>
	<script>
        function getAesString(data,key,iv){//加密
            var key  = CryptoJS.enc.Hex.parse(key); //由于是16进制密钥，所以需要先解析出来
            var iv   = CryptoJS.enc.Utf8.parse(iv);
            var encrypted = CryptoJS.AES.encrypt(data,key,
                    {
                        iv:iv,
                        mode:CryptoJS.mode.CBC,
                        padding:CryptoJS.pad.Pkcs7
                    });
            return encrypted;
        }
        function getDAesString(encrypted,key,iv){//解密
            var key  = CryptoJS.enc.Hex.parse(key);
            var iv   = CryptoJS.enc.Utf8.parse(iv);
            var decrypted = CryptoJS.AES.decrypt(encrypted,key,
                    {
                        iv:iv,
                        mode:CryptoJS.mode.CBC,
                        padding:CryptoJS.pad.Pkcs7
                    });
            return decrypted.toString(CryptoJS.enc.Utf8);
        }
        function getAES(){ //加密
            var data = document.getElementById("data-ipt").value;//明文
            var key  = '12345678901234567890123456789012';  //密钥
            var iv   = '1234567890123456';
            var encrypted = getAesString(data,key,iv); //密文
            document.getElementById("encrypted").innerHTML = encrypted;
        }

        function getDAes(){//解密
            var encrypted = document.getElementById("encrypted").innerHTML; //密文
            var key  = '12345678901234567890123456789012';
            var iv   = '1234567890123456';
            var decryptedStr = getDAesString(encrypted,key,iv);
            document.getElementById("decrypted").innerHTML = decryptedStr;
        }
    	</script>
</body>
</html>
```

参考资料：
[AES加密算法的详细介绍与实现](https://blog.csdn.net/qq_28205153/article/details/55798628)
